<!DOCTYPE html>
<!-- this file is auto-generated from README.md. Do not edited directly -->
<!--
@license webgpu-utils 1.10.1 Copyright (c) 2023, Gregg Tavares All Rights Reserved.
Available via the MIT license.
see: http://github.com/greggman/webgpu-utils for details
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Language" content="en">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="webgpu-utils, a WebGPU helper library" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://greggman.github.io/webgpu-utils/resources/images/twgljs.png" />
<meta property="og:description" content="webgpu-utils, a WebGPU helper library" />
<meta property="og:url" content="https://greggman.github.io/webgpu-utils/" />

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="twgljs.org">
<meta name="twitter:title" content="TWGL.js">
<meta name="twitter:url" content="https://greggman.github.io/webgpu-utils/">
<meta name="twitter:description" content="webgpu-utils, a WebGPU helper library">
<meta name="twitter:image:src" content="https://greggman.github.io/webgpu-utils/resources/images/twgljs.png">


<title>webgpu-utils, a WebGPU helper library</title>

<link rel="stylesheet" href="resources/css/base.css" type="text/css" />
<link href="resources/images/webgpu-helper-icon.png" rel="shortcut icon" type="image/png">
</head>
<body>
<iframe src="examples/background.html"></iframe>
<div id="frame">
  <div class="nav">
    <ul>
      <li><a href="./docs/">Docs</a></li>
      <li><a href="#examples">Examples</a></li>
      <li><a href="#download">Download</a></li>
    </ul>
  </div>
  <div id="content">
    <h1>webgpu-utils</h1>
<p><img src="https://img.shields.io/npm/v/webgpu-utils" alt=""></p>
<h2>Docs</h2>
<p>See <a href="./docs">here</a></p>
<ul>
<li><a href="./CHANGELIST.html">ChangeList</a></li>
<li><a href="./migration.html">Migration Notes</a></li>
</ul>
<h2>Random useful things for WebGPU</h2>
<p>As I do more WebGPU I find I need more and more helpers to make things
less tedious. These are the result. I expect Iâ€™ll add more over time.</p>
<h3>Easily set Uniforms (based on your WGSL structs/types)</h3>
<p>Example:</p>
<pre><code class="lang-js">import {
  makeShaderDataDefinitions,
  makeStructuredView,
} from 'webgpu-utils';

const code = `
struct MyUniforms {
   color: vec4f,
   brightness: f32,
   kernel: array&lt;f32, 9&gt;,
   projectionMatrix: mat4x4f,
};
@group(0) @binding(0) var&lt;uniform&gt; myUniforms: MyUniforms;
`;

const defs = makeShaderDataDefinitions(code);
const myUniformValues = makeStructuredView(defs.uniforms.myUniforms);

// create the correct sized buffer
const uniformBuffer = device.createBuffer({
  size: myUniformValues.arrayBuffer.byteLength,
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
});

// Set some values via set
myUniformValues.set({
  color: [1, 0, 1, 1],
  brightness: 0.8,
  kernel: [
     1, 0, -1,
     2, 0, -2,
     1, 0, -1,
  ],
});

// Set a value by passing it to a math library
mat4.perspective(
    degToRad(45),
    canvas.clientWidth / canvas.clientHeight,
    0.1,
    20,
    myUniformValues.views.projectionMatrix);

// Upload the data to the GPU
device.queue.writeBuffer(uniformBuffer, 0, myUniformValues.arrayBuffer);
</code></pre>
<p>See <a href="./docs/functions/makeStructuredView.html">makeStructuredView</a> for details.</p>
<h3>Load an image URL as a texture (with mips)</h3>
<pre><code class="lang-js">import { createTextureFromImage } from 'webgpu-utils';

const texture = await createTextureFromImage(device, 'https://someimage.url', {
  mips: true,
  flipY: true,
});
</code></pre>
<h3>Load a canvas/video/ImageBitmap as a texture (with mips)</h3>
<pre><code class="lang-js">import { createTextureFromSource } from 'webgpu-utils';

const texture = createTextureFromSource(device, someCanvasVideoImageBitmap, {
  mips: true,
  flipY: true,
});
</code></pre>
<h3>Load 6 images as a cubemap (with mips)</h3>
<pre><code class="lang-js">import { createTextureFromImage } from 'webgpu-utils';

const texture = await createTextureFromImages(device, [
  'images/yokohama/posx.jpg',
  'images/yokohama/negx.jpg',
  'images/yokohama/posy.jpg',
  'images/yokohama/negy.jpg',
  'images/yokohama/posz.jpg',
  'images/yokohama/negz.jpg',
], {
  mips: true,
});
</code></pre>
<h3>Load data as a texture</h3>
<pre><code class="lang-js">import { createTextureFromSource } from 'webgpu-utils';

const r = [255,   0,   0, 255];
const g = [  0, 255,   0, 255];
const b = [  0,   0, 255, 255];
const y = [255, 255,   0, 255];

// if no width or height is passed, then assumes data is rgba8unorm
// if sqrt(numPixels) is in then makes a square. Otherwise Nx1
const data2x2 = [ r, g, b, y ].flat();
const texture2x2 = createTextureFromSource(device, data2x2, {
  mips: true,
});
</code></pre>
<pre><code class="lang-js">const data4x1 = {
  data: [ r, g, b, y ].flat();
  width: 4,
};
const texture4x1 = createTextureFromSource(device, data2x2, {
  mips: true,
});
</code></pre>
<pre><code class="lang-js">const singlePixelWhiteTexture = createTextureFromSource(
    device, [255, 255, 255, 255]);
</code></pre>
<pre><code class="lang-js">const rg16sint2x2 = [
  1,2  3,4,
  5,6, 7,8,
];
const rg16Texture2x2 = createTextureFromSource(
  device, rg16sint2x2, { format: 'rg16sint' });
</code></pre>
<p>All data above can be a TypedArray</p>
<pre><code class="lang-js">const singlePixelRedTexture = createTextureFromSource(
    device, new Uint8Array[255, 0, 0, 255]);
</code></pre>
<h3>Generate mips on an existing texture</h3>
<pre><code class="lang-js">import { numMipLevels, generateMipmap } from 'webgpu-utils';

const size = [8, 8, 1];
const texture = device.createTexture({
  size,
  mipLevelCount: numMipLevels(size);
  format: 'rgba8unorm',
  usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
});

... do whatever you do to fill out the mip level 0 ...

generateMipmap(device, texture);
</code></pre>
<h3>Create Buffers and attributes (interleaved)</h3>
<pre><code class="lang-js">import { numMipLevels, generateMipmap } from 'webgpu-utils';

const bi = wgh.createBuffersAndAttributesFromArrays(device, {
  position: [1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1],
  normal: [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1],
  texcoord: [1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1],
  indices: [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23],
});

const pipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: {
    module,
    entryPoint: 'myVSMain',
    buffers: bi.bufferLayouts,  // &lt;---
  },
  ...
});

// at render time
passEncoder.setVertexBuffer(0, bi.buffers[0]);
passEncoder.setIndexBuffer(bi.indexBuffer, bi.indexFormat);
passEncoder.drawIndexed(bi.numElements);
</code></pre>
<h3>Create <code>GPUBindGroupLayoutDescriptors</code> from WGSL code</h3>
<pre><code class="lang-js">import {
  makeShaderDataDefinitions,
  makeBindGroupLayoutDescriptors,
} from 'webgpu-utils';

const code = `
@group(0) @binding(0) var&lt;uniform&gt; mat: mat4x4f;

struct MyVSOutput {
  @builtin(position) position: vec4f,
  @location(1) texcoord: vec2f,
};

@vertex
fn myVSMain(v: MyVSInput) -&gt; MyVSOutput {
  var vsOut: MyVSOutput;
  vsOut.position = mat * v.position;
  vsOut.texcoord = v.texcoord;
  return vsOut;
}

@group(0) @binding(2) var diffuseSampler: sampler;
@group(0) @binding(3) var diffuseTexture: texture_2d&lt;f32&gt;;

@fragment
fn myFSMain(v: MyVSOutput) -&gt; @location(0) vec4f {
  return textureSample(diffuseTexture, diffuseSampler, v.texcoord);
}
`;

const module = device.createShaderModule({code});
const defs = wgh.makeShaderDataDefinitions(code);

const pipelineDesc = {
  vertex: {
    module,
    entryPoint: 'myVSMain',
    buffers: bufferLayouts,
  },
  fragment: {
    module,
    entryPoint: 'myFSMain',
    targets: [
      {format: presentationFormat},
    ],
  },
};

const descriptors = wgh.makeBindGroupLayoutDescriptors(defs, pipelineDesc);
const group0Layout = device.createBindGroupLayout(descriptors[0]);
const layout = device.createPipelineLayout({
  bindGroupLayouts: [group0Layout],
});
const pipeline = device.createRenderPipeline({
  layout,
  ...pipelineDesc,
});
</code></pre>
<h2>Examples:</h2>
<ul>
<li><a href="examples/cube.html">Cube</a></li>
<li><a href="examples/cube.html">2d-array</a></li>
<li><a href="examples/cube-map.html">Cube-map</a></li>
<li><a href="examples/instancing.html">Instancing</a></li>
<li><a href="examples/instancing-size-only.html">Instancing 2</a></li>
</ul>
<h2>Notes about structured data</h2>
<h3>The first level of an array of intrinsic types is flattened by default.</h3>
<p>Example:</p>
<pre><code class="lang-js">const code = `
@group(0) @binding(0) var&lt;uniform&gt; uni1: array&lt;vec3f, 4&gt;;
@group(0) @binding(1) var&lt;uniform&gt; uni2: array&lt;array&lt;vec3f, 3&gt;, 4&gt;;
`;
const defs = makeShaderDataDefinitions(code);
const uni1 = makeStructuredView(defs.uniforms.uni1);
const uni2 = makeStructuredView(defs.uniforms.uni2);

uni1.set([
  1, 2, 3, 0,  // uni1[0]
  4, 5, 6, 0,  // uni1[1]
  //...
]);

uni2.set([
  [
    1, 2, 3, 0,  // uni2[0][0],
    4, 5, 6, 0,  // uni2[0][1],
  ],
  ,  // uni2[1]
  [
    7, 8, 9, 0,  // uni2[2][0],
    4, 5, 6, 0,  // uni2[2][1],
  ],
]);
</code></pre>
<p>The reason itâ€™s this way is itâ€™s common to make large arrays of <code>f32</code>, <code>u32</code>,
<code>vec2f</code>, <code>vec3f</code>, <code>vec4f</code> etc. We wouldnâ€™t want every element of an array to
have its own typedarray view.</p>
<p>You can configure this per type by calling <code>setIntrinsicsToView</code>.
The configuration is global. Given th example above</p>
<pre><code class="lang-js">const code = `
@group(0) @binding(0) var&lt;uniform&gt; uni1: array&lt;vec3f, 4&gt;;
@group(0) @binding(1) var&lt;uniform&gt; uni2: array&lt;array&lt;vec3f, 3&gt;, 4&gt;;
`;
const defs = makeShaderDataDefinitions(code);
setIntrinsicsToView(['vec3f']);
const uni1 = makeStructuredView(defs.uniforms.uni1);

uni1.set([
  [1, 2, 3],  // uni1[0]
  [4, 5, 6],  // uni1[1]
  ...
]);
</code></pre>
<p>Or to put it another way, in the default case, <code>uni1.views is a Float32Array(16)</code>.
In the 2nd case itâ€™s an array of 4 <code>Float32Array</code> each 3 elements big</p>
<h3>arrays of intrinsics can be set by arrays of arrays</h3>
<pre><code class="lang-js">const code = `
@group(0) @binding(0) var&lt;uniform&gt; uni1: array&lt;vec2f, 4&gt;;
`;
const defs = makeShaderDataDefinitions(code);
const uni1 = makeStructuredView(defs.uniforms.uni1);

uni1.set([
  [1, 2],  // uni1[0]
  [3, 4],  // uni1[1]
]);
</code></pre>
<p>Currently this requires the length of each subarray to match the length of
the intrinsic. The reason being, there is no type data used in <code>uni1.set</code> so
there is nothing to tell it that itâ€™s a <code>vec2f</code>. In this case, it just advances
where itâ€™s writing by the length of the source data sub arrays.</p>
<h3>for unsized arrays you must pass in your own arrayBuffer</h3>
<p>The reason is an unsized arrayâ€™s size is defined to WebGPU by its buffer binding
size. That information is provided at runtime so thereâ€™s no way for webgpu-utils
to know the size. The solution is you pass in an <code>ArrayBuffer</code>.</p>
<p>Example:</p>
<pre><code class="lang-js">const code = `
@group(0) @binding(0) var&lt;storage&gt; buf1: array&lt;vec3f&gt;;  // unsized array
`;
const defs = makeShaderDataDefinitions(code);
const buf1 = makeStructuredView(defs.storages.buf1, new ArrayBuffer(4 * 16));

// buf1.views will be a Float32Array representing 4 vec3fs
</code></pre>
<p>Note: If you have a complex array element type you can call
<code>getSizeAndAlignmentOfUnsizedArrayElement</code> to get its size. Example:</p>
<pre><code class="lang-js">const code = `
struct Light {
  intensity: f32,
  direction: vec3f,
};
@group(0) @binding(7) var&lt;storage&gt; lights: array&lt;Light&gt;;
`;
const defs = makeShaderDataDefinitions(code);
const {size} = getSizeAndAlignmentOfUnsizedArrayElement(defs.storages.lights);
const numLights = 4;
const buf1 = makeStructuredView(
    defs.storages.lights, new ArrayBuffer(numLights * size));
</code></pre>
<p>Similarly if you are using an unsized array as the last member of a struct
you might do this</p>
<pre><code class="lang-js">const code = `
struct Kernel {
  amount: f32,
  entries: array&lt;vec3f&gt;,
};
@group(0) @binding(7) var&lt;storage&gt; conv: Kernel;
`;
const defs = makeShaderDataDefinitions(code);
const {size: elemSize} = getSizeAndAlignmentOfUnsizedArrayElement(defs.storages.conv);
const numKernelEntries = 4;
const size = defs.storages.conv.size + numKernelEntries * elemSize;
const buf1 = makeStructuredView(
    defs.storages.conv, new ArrayBuffer(size));
)
</code></pre>
<h2>Usage</h2>
<ul>
<li>include from the net</li>
</ul>
<pre><code class="lang-js">import { createTextureFromImage } from 'https://greggman.github.io/webgpu-utils/dist/1.x/webgpu-utils.module.js'

...
</code></pre>
<ul>
<li>
<p><a href="https://jsgist.org/?src=30dfc8cb81777219dd9e91d9471452d0">Live Example 1</a></p>
</li>
<li>
<p>npm</p>
</li>
</ul>
<pre><code class="lang-sh">npm install webgpu-utils
</code></pre>
<pre><code class="lang-js">import { createTextureFromImage } from 'webgpu-utils';

...
</code></pre>
<h2><a id="examples"></a> Examples</h2>
<ul>
<li><a href="examples/2d-array.html">2d-array texture</a></li>
<li><a href="examples/cube.html">cube</a></li>
<li><a href="examples/cube-map.html">cube-map</a></li>
<li><a href="examples/instancing.html">instancing</a></li>
<li><a href="examples/primitives.html">primitives</a></li>
<li><a href="examples/reverse-z.html">reverse-z</a></li>
<li><a href="examples/stencil.html">stencil</a></li>
<li><a href="examples/stencil-cube.html">stencil-cube</a></li>
</ul>
<h2>Development</h2>
<pre><code>git clone https://github.com/greggman/webgpu-utils.git
cd webgpu-utils
npm ci
npm start
</code></pre>
<p>This will run rollup in watch mode, building from typescript into
<code>dist/1.x/webgpu-utils.js</code> and start a server</p>
<p>Now open <a href="http://localhost:8080/test/"><code>http://localhost:8080/test/</code></a> to run tests.</p>
<h2>Thanks</h2>
<p>Super thanks to Brendan Duncan for <a href="https://github.com/brendan-duncan/wgsl_reflect">wgsl-reflect</a> on which much of this is based.</p>
<h2>License</h2>
<p><a href="LICENSE.md">MIT</a></p>

  </div>
</div>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 12px;
    line-height: 24px;
    position: relative;
    transition: 0.5s;
    display: block;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

@media screen and (min-width: 400px){
    #forkongithub{
        position: fixed;
        display: block;
        top: 0;
        right: 0;
        width: 200px;
        overflow: hidden;
        height: 200px;
        z-index: 9999;
    }
    #forkongithub a{
        width: 200px;
        position: absolute;
        top: 40px;
        right: -40px;
        transform: rotate(45deg);
        -webkit-transform: rotate(45deg);
        -ms-transform: rotate(45deg);
        -moz-transform: rotate(45deg);
        -o-transform: rotate(45deg);
        box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/greggman/webgpu-utils">Fork me on GitHub</a></div>
</body>
<script src="examples/3rdparty/prettify.js"></script>
<script src="resources/js/index.js"></script>
</html>


