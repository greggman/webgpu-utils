<!DOCTYPE html>
<!-- this file is auto-generated from README.md. Do not edited directly -->
<!--
@license webgpu-utils 0.14.2 Copyright (c) 2023, Gregg Tavares All Rights Reserved.
Available via the MIT license.
see: http://github.com/greggman/webgpu-utils for details
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Language" content="en">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="webgpu-utils, a WebGPU helper library" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://greggman.github.io/webgpu-utils/resources/images/twgljs.png" />
<meta property="og:description" content="webgpu-utils, a WebGPU helper library" />
<meta property="og:url" content="https://greggman.github.io/webgpu-utils/" />

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="twgljs.org">
<meta name="twitter:title" content="TWGL.js">
<meta name="twitter:url" content="https://greggman.github.io/webgpu-utils/">
<meta name="twitter:description" content="webgpu-utils, a WebGPU helper library">
<meta name="twitter:image:src" content="https://greggman.github.io/webgpu-utils/resources/images/twgljs.png">


<title>webgpu-utils, a WebGPU helper library</title>

<link rel="stylesheet" href="resources/css/base.css" type="text/css" />
<link href="resources/images/webgpu-helper-icon.png" rel="shortcut icon" type="image/png">
</head>
<body>
<iframe src="examples/background.html"></iframe>
<div id="frame">
  <div class="nav">
    <ul>
      <li><a href="./docs/">Docs</a></li>
      <li><a href="#examples">Examples</a></li>
      <li><a href="#download">Download</a></li>
    </ul>
  </div>
  <div id="content">
    <h1>webgpu-utils</h1>
<p><img src="https://img.shields.io/npm/v/webgpu-utils" alt=""></p>
<h2>Docs</h2>
<p>See <a href="./docs">here</a></p>
<h2>Random useful things for WebGPU</h2>
<p>As I do more WebGPU I find I need more and more helpers to make things
less tedious. These are the result. I expect I’ll add more over time.</p>
<p>Note: At the moment, minified and gzipped this is only 9k! It’s also
possible to tree shake so you’ll only get what you use.</p>
<h3>Easily set Uniforms (based on your WGSL structs/types)</h3>
<p>Example:</p>
<pre><code class="lang-js">import {
  makeShaderDataDefinitions,
  makeStructuredView,
} from 'webgpu-utils';

const code = `
struct MyUniforms {
   color: vec4f,
   brightness: f32,
   kernel: array&lt;f32, 9&gt;,
   projectionMatrix: mat4x4f,
};
@group(0) @binding(0) var&lt;uniform&gt; myUniforms: MyUniforms;
`;

const defs = makeShaderDataDefinitions(code);
const myUniformValues = makeStructuredView(defs.uniforms.myUniforms);

// create the correct sized buffer
const uniformBuffer = device.createBuffer({
  size: myUniformBuffer.arrayBuffer.byteLength,
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
});

// Set some values via set
myUniformValues.set({
  color: [1, 0, 1, 1],
  brightness: 0.8,
  kernel: [
     1, 0, -1,
     2, 0, -2,
     1, 0, -1,
  ],
});

// Set a value by passing it to a math library
mat4.perspective(
    degToRad(45),
    canvas.clientWidth / canvas.clientHeight,
    0.1,
    20,
    myUniformValues.views.projectionMatrix);

// Upload the data to the GPU
device.queue.writeBuffer(uniformBuffer, 0, myUniformValues.arrayBuffer);
</code></pre>
<h3>Load an image URL as a texture (with mips)</h3>
<pre><code class="lang-js">import { createTextureFromImage } from 'webgpu-utils';

const texture = await createTextureFromImage(device, 'https://someimage.url', {
  mips: true,
  flipY: true,
});
</code></pre>
<h3>Load a canvas/video/ImageBitmap as a texture (with mips)</h3>
<pre><code class="lang-js">import { createTextureFromSource } from 'webgpu-utils';

const texture = createTextureFromSource(device, someCanvasVideoImageBitmap, {
  mips: true,
  flipY: true,
});
</code></pre>
<h3>Load 6 images as a cubemap (with mips)</h3>
<p>import { createTextureFromImage } from ‘webgpu-utils’;</p>
<pre><code class="lang-js">  const texture = await createTextureFromImages(device, [
    'images/yokohama/posx.jpg',
    'images/yokohama/negx.jpg',
    'images/yokohama/posy.jpg',
    'images/yokohama/negy.jpg',
    'images/yokohama/posz.jpg',
    'images/yokohama/negz.jpg',
  ], {
    mips: true,
  });
</code></pre>
<h3>Load data as a texture</h3>
<pre><code class="lang-js">import { createTextureFromSource } from 'webgpu-utils';

const r = [255,   0,   0, 255];
const g = [  0, 255,   0, 255];
const b = [  0,   0, 255, 255];
const y = [255, 255,   0, 255];

// if no width or height is passed, then assumes data is rgba8unorm
// if sqrt(numPixels) is in then makes a square. Otherwise Nx1
const data2x2 = [ r, g, b, y ].flat();
const texture2x2 = createTextureFromSource(device, data2x2, {
  mips: true,
});
</code></pre>
<pre><code class="lang-js">const data4x1 = {
  data: [ r, g, b, y ].flat();
  width: 4,
};
const texture4x1 = createTextureFromSource(device, data2x2, {
  mips: true,
});
</code></pre>
<pre><code class="lang-js">const singlePixelWhiteTexture = createTextureFromSource(
    device, [255, 255, 255, 255]);
</code></pre>
<pre><code class="lang-js">const rg16sint2x2 = [
  1,2  3,4,
  5,6, 7,8,
];
const rg16Texture2x2 = createTextureFromSource(
  device, rg16sint2x2, { format: 'rg16sint' });
</code></pre>
<p>All data above can be a TypedArray</p>
<pre><code class="lang-js">const singlePixelRedTexture = createTextureFromSource(
    device, new Uint8Array[255, 0, 0, 255]);
</code></pre>
<h3>Generate mips on an existing texture</h3>
<pre><code class="lang-js">import { numMipLevels, generateMipmap } from 'webgpu-utils';

const size = [8, 8, 1];
const texture = device.createTexture({
  size,
  mipLevelCount: numMipLevels(size);
  format: 'rgba8unorm',
  usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
});

... do whatever you do to fill out the mip level 0 ...

generateMipmap(device, texture);
</code></pre>
<h3>Create Buffers and attributes (interleaved)</h3>
<pre><code class="lang-js">import { numMipLevels, generateMipmap } from 'webgpu-utils';

const bi = wgh.createBuffersAndAttributesFromArrays(device, {
  position: [1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1],
  normal: [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1],
  texcoord: [1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1],
  indices: [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23],
});

const pipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: {
    module,
    entryPoint: 'myVSMain',
    buffers: bi.bufferLayouts,  // &lt;---
  },
  ...
});

// at render time
passEncoder.setVertexBuffer(0, bi.buffers[0]);
passEncoder.setIndexBuffer(bi.indexBuffer, bi.indexFormat);
passEncoder.drawIndexed(bi.numElements);
</code></pre>
<h2>Examples:</h2>
<ul>
<li><a href="examples/cube.html">Cube</a></li>
<li><a href="examples/cube.html">2d-array</a></li>
<li><a href="examples/cube-map.html">Cube-map</a></li>
<li><a href="examples/instancing.html">Instancing</a></li>
<li><a href="examples/instancing-size-only.html">Instancing 2</a></li>
</ul>
<h2>Notes about structured data</h2>
<h3>The first level of an array of intrinsic types is flattened.</h3>
<p>Example:</p>
<pre><code class="lang-js">const code = `
@group(0) @binding(0) var&lt;uniform&gt; uni1: array&lt;vec3f, 4&gt;;
@group(0) @binding(1) var&lt;uniform&gt; uni2: array&lt;array&lt;vec3f, 3&gt;, 4&gt;;
`;
const defs = makeShaderDataDefinitions(code);
const uni1 = makeStructuredView(defs.uniforms.uni1);
const uni2 = makeStructuredView(defs.uniforms.uni2);

uni1.set([
  1, 2, 3, 0,  // uni1[0]
  4, 5, 6, 0,  // uni1[1]
  //...
]);

uni2.set([
  [
    1, 2, 3, 0,  // uni2[0][0],
    4, 5, 6, 0,  // uni2[0][1],
  ],
  ,  // uni2[1]
  [
    7, 8, 9, 0,  // uni2[2][0],
    4, 5, 6, 0,  // uni2[2][1],
  ],
]);
</code></pre>
<p>The reason it’s this way is it’s common to make large arrays of <code>f32</code>, <code>u32</code>,
<code>vec2f</code>, <code>vec3f</code>, <code>vec4f</code> etc. We wouldn’t want every element of an array to
have its own typedarray view.</p>
<h3>arrays of intrinsics can be set by arrays of arrays</h3>
<pre><code class="lang-js">const code = `
@group(0) @binding(0) var&lt;uniform&gt; uni1: array&lt;vec2f, 4&gt;;
`;
const defs = makeShaderDataDefinitions(code);
const uni1 = makeStructuredView(defs.uniforms.uni1);

uni1.set([
  [1, 2],  // uni1[0]
  [3, 4],  // uni1[1]
]);
</code></pre>
<p>Currently this requires the length of each subarray to match the length of
the intrinsic. The reason being, there is no type data used in <code>uni1.set</code> so
there is nothing to tell it that it’s a <code>vec2f</code>. In this case, it just advances
where it’s writing by the length of the source data sub arrays.</p>
<h3>for unsized arrays you must pass in your own arrayBuffer</h3>
<p>The reason is an unsized array’s size is defined to WebGPU by its buffer binding
size. That information is provided at runtime so there’s no way for webgpu-utils
to know the size. The solution is you pass in an <code>ArrayBuffer</code>.</p>
<p>Example:</p>
<pre><code class="lang-js">const code = `
@group(0) @binding(0) var&lt;uniform&gt; uni1: array&lt;vec3f&gt;;  // unsized array
`;
const defs = makeShaderDataDefinitions(code);
const uni1 = makeStructuredView(defs.uniforms.uni1, new ArrayBuffer(4 * 16));

// uni.views will be a Float32Array representing 4 vec3fs
</code></pre>
<h2>Usage</h2>
<ul>
<li>include from the net</li>
</ul>
<pre><code class="lang-js">import { createTextureFromImage } from 'https://greggman.github.io/webgpu-utils/dist/0.x/webgpu-utils.module.js'

...
</code></pre>
<ul>
<li>
<p><a href="https://jsgist.org/?src=30dfc8cb81777219dd9e91d9471452d0">Live Example 1</a></p>
</li>
<li>
<p>npm</p>
</li>
</ul>
<pre><code class="lang-sh">npm install webgpu-utils
</code></pre>
<pre><code class="lang-js">import { createTextureFromImage } from 'webgpu-utils';

...
</code></pre>
<h2>Development</h2>
<pre><code>git clone https://github.com/greggman/webgpu-utils.git
cd webgpu-utils
npm install
npm start
</code></pre>
<p>This will run rollup in watch mode, building from typescript into
<code>dist/0.x/webgpu-utils.js</code>.</p>
<pre><code>npx servez
</code></pre>
<p>Now open <a href="http://localhost:8080/test/"><code>http://localhost:8080/test/</code></a> to run tests.</p>
<h2>Thanks</h2>
<p>Super thanks to Brendan Duncan for <a href="https://github.com/brendan-duncan/wgsl_reflect">wgsl-reflect</a> on which much of this is based.</p>
<h2>License</h2>
<p><a href="LICENSE.md">MIT</a></p>

  </div>
</div>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 12px;
    line-height: 24px;
    position: relative;
    transition: 0.5s;
    display: block;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

@media screen and (min-width: 400px){
    #forkongithub{
        position: fixed;
        display: block;
        top: 0;
        right: 0;
        width: 200px;
        overflow: hidden;
        height: 200px;
        z-index: 9999;
    }
    #forkongithub a{
        width: 200px;
        position: absolute;
        top: 40px;
        right: -40px;
        transform: rotate(45deg);
        -webkit-transform: rotate(45deg);
        -ms-transform: rotate(45deg);
        -moz-transform: rotate(45deg);
        -o-transform: rotate(45deg);
        box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/greggman/webgpu-utils">Fork me on GitHub</a></div>
</body>
<script src="examples/3rdparty/prettify.js"></script>
<script src="resources/js/index.js"></script>
</html>


